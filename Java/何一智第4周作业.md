# 什么是线程和进程

进程是对正在运行中的程序的一个抽象，由程序+当前运行的上下文组成，是系统进行资源分配的基本单位。操作系统的所有内容都是围绕进程展开的，负责执行任务的是 CPU。

上下文是由程序所需的状态组成，包括数据、堆栈、寄存器、程序计数器等。

线程是操作系统能够进行运算调度和执行的最小单位，负责当前进程中程序的执行。

一个进程至少要有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享资源。

当一个线程的时间片用完之后或者自身原因被迫暂停运行了，这时候，另外一个线程或者、进程或者其他进程的线程就会被操作系统选中，用来占用处理器，这就是上下文切换。

并发指的是同一个时间段中有几个程序都处于已启动到运行完毕之间的状态，并且这几个程序是在同一个 CPU 上进行处理的，这个叫做并发。

并行指的是在多核系统中，多个 CPU 可以同时执行多个进程，这几个进程是真正意义上的同时运行，这种方式叫做并行。

# 使用多线程会带来什么问题

1. 线程安全问题：多个线程同时访问共享的资源，可能会出现数据竞争和数据不一致的情况。
2. 死锁问题：如果多个线程同时持有某些资源，并且互相等待对方释放资源，可能就会出现死锁
3. 上下文切换问题：线程切换需要保存和恢复上下文，这个过程会带来一定的开销
4. 线程安全性能问题：在使用同步机制的时候，会存在性能上的损失
5. 共享资源限制问题：如果多个线程同时访问同一个共享资源，可能会导致该资源的访问量过大产生瓶颈

## 原子性

原子性定义为一个或多个操作，要么全部执行要么全部不执行，中间一旦有一个操作失败，就全部回滚。

比如我们看这几个操作：

```java
i = 0;
j = i;
i++;
i = j + 1;
```

这里只有第一个操作 `i=0` 是原子的，剩下的全都不是原子操作。在多线程环境下，Java 只保证了基本数据类型的变量和赋值操作才是原子性的，如果要保证原子性，那么需要加锁或者其他操作。

## 可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。

最简单的例子：

```java
// 线程1
int i = 0;
i = 10;

// 线程2
j = i
```

根据 java 内存模型，两个不同线程有自己的独立本地内存，里面的变量都是副本，因为没有可见性的保证，线程 2 很可能无法感知到线程 1 中 `i=10` 的变动，而一直认为 `i=0`。

对于可见性，Java 提供了 `volatile` 关键字来保证可见性。同时，通过 `synchronized` 和 `Lock` 也能保证可见性。

## 有序性

顾名思义，就是程序执行的顺序按照代码的先后顺序执行。

```java
int i = 0;
boolean flag = false;
i = 1;
flag = true;
```

在单线程的情况下，因为 `i=1` 和 `flag=true` 的执行顺序不会影响结果，所以 CPU 可能会将这两行的执行顺序变化。也就是说，CPU 为了提高程序运行效率，可能会对输入代码进行优化，不保证程序中各个语句的执行先后顺序和代码中的一致，但是能保证程序最终执行结果和代码顺序的执行结果一致。

这种在单线程的情况下没问题，但是多线程情况下，可能正确性就会收到影响。

在 Java 内存模型中，允许编译器和处理器对指令重排序，但是同样也会影响到多线程并发执行的正确性。

在 Java 里面，可以通过 `volatile` 关键字来保证一定的有序性，同样可以通过 `synchronized` 和 `Lock` 来保证有序性（这是因为 `synchronized` 是保证同一时刻只有一个线程可以执行这段代码，那天然就保证了有序性）

# 什么是死锁？如何排查死锁?

死锁是指两个或两个以上的运算单元（进程、线程或者协程）都在等待对方释放资源，但没有一方释放资源，从而造成了一种阻塞的现象就成为死锁。

死锁产生的原因有 4 个：
1. 互斥条件：指运算单元对所分配到的资源具有排他性，也就是在同一个时间段内某个锁资源只能被一个运算单元所占有
2. 请求和保持条件：指运算单元已经获得了一个资源，并且又对一个已经被占有的资源提出请求，并且一直保持对自身资源的占有
3. 不可剥夺条件：指运算单元已获得的资源在没使用完之前，不能被剥夺
4. 环路等待条件：在死锁发生的时候，两个线程获取资源的顺序构成了环形链

以上四个条件同时满足的时候就会出现死锁

排查死锁的方式：

可以使用 `jstack` 工具来排查是否出现死锁。

还可以通过 `Arthas` 、`GCEasy`、`MAT`、`VisualVM` 等工具来排查是否出现死锁。

