---
categories:
  - 程序员
  - 编程语言
  - Java
  - 极客时间高级Java工程师
  - 03-JVM
---
# 题目 1

## 用自己语言介绍 Java 运行时数据区

###  堆

1. Java 堆是用来存放对象实例的区域，Java 几乎所有的对象实例都在这里被分配（除了标量替换等优化手段出现后让少部分对象可以分配在栈上）。
2. 所有线程共享 Java 堆，Java 堆是和 JVM 进程绑定的，一个 JVM 进程对应一个 Java 堆。
3. 堆是垃圾回收的重点区域
4. 堆分为年轻代、老年代和永久代（元空间），分代的原因是因为 70%以上的对象都是临时对象，而存在越久的对象，越不应该被清理。因此提出了分代理论，在年轻代频繁进行垃圾回收，在老年代进行较少的垃圾回收，在永久代（元空间）几乎不进行垃圾回收
5. 堆在实际分配中并不一定是要连续的，但是在逻辑上需要是连续的
6. 在堆空间不足时会产生 OOM 异常

### 栈

1. 栈是运行时的单位。决定了程序应该如何执行
2. 栈是和线程绑定的，线程私有，每个栈对应一个 Java 的方法调用
3. 栈的内部保存着一个个的栈帧，方法开始执行时，一个栈帧入栈，方法执行完成时，一个栈帧出栈
4. 栈帧中存储着局部变量表、操作数栈、动态链接、方法返回地址和一些其他的附加信息
5. 对于栈不存在垃圾回收
6. 栈中可能出现 StackOverFlow 异常和 OOM 异常，前者是因为栈深度不够，在递归调用时可能出现异常，后者是因为内存不够产生的异常

### 方法区

1. 方法区和堆一样，是和 JVM 进程相绑定的一块内存区域，所有线程共享，在 JVM 启动时创建，也是一块逻辑上连续，但是物理内存可以不连续的区域
2. 方法区存放的是对象的模板数据，也就是类型数据，包括类型信息（类名、修饰符 public 等）、常量、静态变量等
3. 当定义的类过多时，方法区存储不下，也会抛出 OOM
4. 方法区经过 3 次比较大的变动，在 JDK 6 以前，方法区在堆的永久代中，在 JDK 7 中，方法区是堆中独立的一块区域，在 JDK 8 以及之后，方法区使用的是本地内存。
5. 方法区基本不进行垃圾收集

### 运行时常量池

1. 运行时常量池是方法区的一部分，它的作用是存放 java 源文件编译之后产生的支持数据，因为这些支持数据会很大，不能直接放到栈帧之中，因此会将这些信息存入到常量池中，然后栈帧中存放的是对常量池的引用，在动态链接时会用到运行时常量池
2. 常量池中包含有数量值、字符串、类引用等信息，这部分在类加载之后会存放到运行时常量池中
3. 运行时常量池相比于常量池，很重要的一点是其具备动态性，比如调用 `String.intern()` 方法就可以将数据从堆中放入运行时常量池里。
4. 当创建类或者接口时，如果构建运行时常量池所需的内存空间超标，会报 OOM

### 直接内存

1. 直接内存不是虚拟机运行时数据区域的一部分，也不是虚拟机规范中的一部分，但是这部分也经常被使用，并且也会产生 OOM（内存直接不够的情况）
2. 直接内存来自于 NIO，可以用 jdk 提供的 native 方法进行操作
3. 通常情况下，如果读写频繁的场合，使用直接内存是比较优的方式，如果是大量创建对象的场合，使用堆内存是比较优秀的方式

## 为什么堆内存要分年轻代和老年代

因为根据研究表明，70%以上的对象都是朝生夕死，也就是创建出来一会儿就死亡了，但是剩余的没有朝生夕死的对象能存活的时间都比较长，因此提出了分代理论，对于年轻代，会进行大量的垃圾收集，保证有足够的空间来创建新的对象。对于老年代，垃圾收集的频率可以很低。

# 题目 2 - 描述一个 Java 对象的生命周期

## 对象的创建和内存分配

1. 首先判断对象对应的类是否已经被加载、链接和初始化，如果没有则采用双亲委派机制去加载对应的类
2. 确认类已经被加载之后，那么就为对象分配内存。首先会计算对象占用空间的大小（通过该对象所有的属性来计算），然后在堆内存中分配出一块内存给这个新对象。如果内存规整，那么采用指针碰撞的方式来分配内存，也就是当前指针指向最新的一块内存空闲区域，将连续的内存空间分配给新对象之后，当前指针指向更新之后的区域。如果内存不规整，那么采用空闲列表方式进行分配，此时 JVM 会维护一个空闲列表，明确哪些区域内存还没有被使用，再分配的时候找到一块足够大的空闲区域分配给新对象即可
3. 对分配的空间进行初始化，也就是将对象的属性赋予初始值
4. 设置对象的对象头，将对象的 hashcode 和 GC 信息等数据存储在对象头中，此时的 hashcode 还是空的，因为只有调用 `.hashCode()` 方法之后才会赋予真正的 hashCode，但是其余信息都是真实的
5. 执行 `init()` 方法进行初始化，此时才是真正的程序员可以控制的地方，会根据程序员的代码进行初始化
6. 此时一个对象已经被完整创建出来了。

## 对象的销毁

JVM 会定时采用引用计数法或者可达性分析算法来检查哪些对象是垃圾了。现在基本采用的算法都是可达性分析算法，会选用一系列根对象（一般包括虚拟机栈中引用的对象、方法区中类静态属性引用的对象等）来扫描，这些对象无法关联到的对象就认为是垃圾对象，开启垃圾回收。

扫描完成之后的垃圾对象会经历一次筛选，如果该对象实现了 `finalize()` 方法，并且该方法并没有被调用过，那么就会调用一次这个方法，如果调用方法后重新和根对象产生了联系，那么该对象还是不会被销毁的

如果上面两次过程之后，发现该对象的确已经是垃圾了，那么直接进行垃圾回收，该对象的内存区域会被销毁。

## 对象的两种访问方式：

1. 句柄访问
	- 此时会在 Java 堆中专门划分出一块内存来作为句柄池，虚拟机栈中的 reference 存储的就是对象的句柄地址，而句柄地址中包含了对象实例数据和类型数据的具体指针。包含对象实例数据的指针指向堆内存的具体对象，类型数据指针指向方法区中的对象元数据。
2. 直接指针
	- 此时虚拟机栈的 reference 指向的是堆内存中具体的对象内存地址，而堆中的对象会包含一个指向方法区中对象类型信息的指针
 
使用句柄访问的优势在与在发生垃圾回收之后，即使堆中对象被移动了，只需要改变句柄中实例对象的指针指向即可，而不需要去改变虚拟机栈中的 reference，缺点是多了一层访问，速度肯定更慢。直接指针就正好和句柄访问相反，访问速度很快，但是一旦对象被移动了，就需要修改所有虚拟机栈中的 reference 值，比较麻烦

## 为什么需要内存担保

每次发生 minor GC 的时候，JVM 会检查老年代的剩余空间是否大于新生代的总空间，如果大于才能发生 minor GC，如果小于，则相当于新生代的对象是无法全部进入老年代的，此时就需要内存担保，使用每次垃圾回收之后晋升到老年代的对象大小的平均值作为参考，使用这个平均值来判断是否能进行 FULL GC，让老年代来腾出更多的空间。

# 题目 3

## 垃圾收集算法有哪些

- 标记清除算法
- 复制算法
- 标记整理算法
- 分代收集算法

## 垃圾收集器有哪些，特点是什么

- Serial (串行 GC)收集器

新生代收集器，单线程，采用复制算法，缺点是进行垃圾收集的时候必须 stop the world，优点是收集效率高

- ParNew (并行 GC)收集器

就是 serial 收集器的并行版本

- Parallel Scavenge (并行回收 GC)收集器

新生代收集器，也是复制算法的收集器，特点是达到一个可控制的吞吐量

- Serial Old (串行 GC)收集器

是 serial 收集器的老年代版本，单线程，采用标记整理算法

- Parallel Old (并行 GC)收集器

Paraller Scavenge 收集器的老年代版本，使用多线程和标记整理算法来进行收集

- CMS (并发 GC)收集器

以最短停顿时间为目标的收集器，基于标记清除算法

- G1 收集器

基于标记整理算法，不会产生空间碎片

## 垃圾收集器的特点


